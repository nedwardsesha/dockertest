"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Command_1 = require("../Command");
class InsertBase extends Command_1.default {
    constructor(table) {
        super();
        this.statement.table = table;
        this.statement.columns = [];
        // values should be as long as columns -- it'll often be $variables, but not necessarily
        this.statement.values = [];
        this.statement.returning = [];
    }
    /**
    Generates a string like:
      INSERT INTO responses (user_id, experiment_id, stimulus_id, value)
        VALUES ($1, $2, $3, $4)
    */
    toSQL() {
        const parts = ['INSERT INTO', this.statement.table];
        // no columns means ALL columns, in default order
        if (this.statement.columns.length > 0) {
            parts.push(`(${this.statement.columns.join(', ')})`);
        }
        // no values means defaults only
        if (this.statement.values.length === 0) {
            parts.push('DEFAULT VALUES');
        }
        else {
            parts.push(`VALUES (${this.statement.values.join(', ')})`);
        }
        if (this.statement.returning.length > 0) {
            // not default since sqlite can't handle it
            parts.push('RETURNING', this.statement.returning.join(', '));
        }
        return parts.join(' ');
    }
    _add(column, value) {
        this.statement.columns.push(column);
        this.parameters[column] = value;
        this.statement.values.push(`$${column}`);
        return this;
    }
    add(column, value) {
        return this.clone()._add(column, value);
    }
    _set(hash) {
        for (const column in hash) {
            const value = hash[column];
            if (value !== undefined) {
                this._add(column, value);
            }
        }
        return this;
    }
    /**
    This function presumes that all hash keys are safe, and all object values are unsafe.
  
    Ignores undefined values.
    */
    set(hash) {
        return this.clone()._set(hash);
    }
    _returning(...columns) {
        this.statement.returning.push(...columns);
        return this;
    }
    /**
    Call like:
  
        db.Insert('users').set({name: 'Chris'}).returning('*')
  
    to get back the full inserted row. Useful if you want the primary key or
    other generated / default values.
    */
    returning(...columns) {
        return this.clone()._returning(...columns);
    }
}
exports.InsertBase = InsertBase;
class Insert extends InsertBase {
}
exports.default = Insert;
/**
The user is still responsible for adding the .returning('*') clause.
*/
class InsertOne extends InsertBase {
    constructor(table) {
        super(table);
        this._oneResult = true;
    }
}
exports.InsertOne = InsertOne;
