import Command from '../Command';
export declare abstract class UpdateBase<R> extends Command<R> {
    constructor(table: string);
    /**
    Generates a string like:
      UPDATE users SET ip = $1, user_agent = $2 WHERE id = $3
    */
    toSQL(): string;
    _where(sql: string, ...args: any[]): this;
    where(sql: string, ...args: any[]): this;
    _whereEqual(hash: {
        [index: string]: any;
    }): this;
    /**
    Just like Select#whereEqual
    */
    whereEqual(hash: {
        [index: string]: any;
    }): this;
    _set(sql: string, ...args: any[]): this;
    /**
    SQL can do more than just stuff like "... SET name = 'Chris' ...", it can also
    increment, e.g., "... SET counter = counter + 1 ...", so we call this _set,
    and have a separate _setEqual
    */
    set(sql: string, ...args: any[]): this;
    _setEqual(hash: {
        [index: string]: any;
    }): this;
    /**
    Given a hash like
        {
          artist: 'Nathaniel Merriweather',
          title: 'Strangers On A Train'
        }
  
    Add this.statement.sets like:
        [
          'artist = $artist',
          'title = $title',
        ]
  
    While extending the parameters with:
        {
          artist: 'Nathaniel Merriweather',
          title: 'Strangers On A Train',
        }
  
    This function presumes that all object keys are safe, and all object values are unsafe.
    In this way, it's a lot like the Select#_whereEqual() method
  
    If that's not true, you should add values to `this.eqs` directly.
    */
    setEqual(hash: {
        [index: string]: any;
    }): this;
    /**
    Call like:
  
        db.Update('users').set({active: false}).returning('*')
  
    to get back all updated rows.
    */
    _returning(...columns: string[]): this;
    returning(...columns: string[]): this;
}
export default class Update extends UpdateBase<any[]> {
}
export declare class UpdateOne extends UpdateBase<any> {
    constructor(table: string);
}
