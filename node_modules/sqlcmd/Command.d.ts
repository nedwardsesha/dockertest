/**
Command represents an abstract SQL command.
*/
declare abstract class Command<R> {
    connection: any;
    /**
    Contains the fields that, together with the class, determine
    how to generate this command's actual SQL, e.g., when calling Command#toSQL().
    */
    statement: any;
    /**
    The parameters used in a parameterized query, matching the
    $name sequences in the generated SQL.
    */
    parameters: any;
    /**
    Used to keep track of positional parameters.
    */
    parameters_i: number;
    protected _oneResult: boolean;
    /**
    When a command is created via a connection's instance methods, e.g.,
    conn.Select(...), the connection will be attached to the command. This method
    calls #executeCommand(...) on the originating connection, and will throw an Error if
    there is no available connection. This may be the case if the command was
    imported and instantiated directly, i.e., by calling
    Select = require('sqlcmd/commands/select').
  
    callback
      sent directly to this.connection.execute(command, callback)
    */
    execute(callback: (error: Error, result?: R) => void): void;
    /**
    If there is a global type 'Promise' available, use it -- otherwise, throw an exception.
    */
    executePromise(): Promise<R>;
    clone(): this;
    abstract toSQL(): string;
    /**
    Replace a SQL string like 'name = ?' and args like ['chris']
    with a SQL string like 'name = $1' while updating Params#store
    so that Params#store['1'] = 'chris'
  
    Returns a string with all ?'s replaced with $1, $2, $3, etc., using the next
    available $N in Params, based on the current value of Params#index.
  
    If there are more ?'s than items in args, it will use the parameterized value,
    `undefined`, for the later ?'s. If there are more items in args than there are
    ?'s, those later items will be ignored.
    */
    protected interpolateQuestionMarks(sql: string, args: any[]): string;
    protected nextParameterName(): string;
}
export default Command;
